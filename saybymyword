fork, vfork
fork不会阻塞父进程，子进程与父进程使用的是不同的物理内存;
vfork创建的子进程与父进程共用一块内存，创建的子进程会阻塞父进程，只有当子进程退出返回后，父进程才可以继续执行。


################################################################################################################
pthread_detach()
pthread_join()
include <pthread.h> 
gcc编译时需增加选项 -lpthread，因为pthread.h不是linux系统默认库，所以需要手动连接线程库。
pthread_detach函数用来将子线程从主线程分离，不会阻塞主线程执行，线程退出时，资源自动回收。
pthread_join函数将子线程合并到主线程，主线程阻塞等待子程结束，然后回收子线程资源。

pthread_create()
pthread_mutex_lock()
pthread_mutex_unlock()
pthread_mutex_init()
pthread_mutex_t


################################################################################################################
accept阻塞等待客户端请求


################################################################################################################
inet_ntoa()将整型转换成ip4字符串.
所在头文件:<arpa/inet.h>


################################################################################################################
read阻塞主进程，等待用户输入


################################################################################################################
connect, 用于发送客户端连接请求
socket, 套接字服务器、客户端间通讯可以直接使用read,write进行，参数都是三个，一个套接字描述符，一个要传的内容，一个内容长度。
       当然也可以使用send, recv, sendto, recvfrom来实现基于套接字的服务器、客户端通讯。

socket建立连接流程：
服务器端：
  socket-> 创建服务器端的套接字，得到套接字描述符
       setsockopt-> 
	        bind->绑定服务器IP和端口，因为服务器上可能有多个网卡，所以一般设置IP为INADDR_ANY，即0.0.0.0表示本机上的所有IP
		    listen->启动套接字监听
			   accept->阻塞主进程直接等到客户端请求到来，同时返回客户端的套接字描述符、IP、Port.

客户端：
	socket->创建客户端套接字
		connect发送客户端连接请求至服务器端

连接建立后，可以使用read, write进行通信了。

结束通信后，使用close关闭套接字。
################################################################################################################


